//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (16)
//--------------------------------------------------------------------------------
pub const GESTURECONFIG_ID = packed struct(u32) {
    BEGIN: u1 = 0,
    END: u1 = 0,
    PAN: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const GID_BEGIN = GESTURECONFIG_ID{ .BEGIN = 1 };
pub const GID_END = GESTURECONFIG_ID{ .END = 1 };
pub const GID_ZOOM = GESTURECONFIG_ID{
    .BEGIN = 1,
    .END = 1,
};
pub const GID_PAN = GESTURECONFIG_ID{ .PAN = 1 };
pub const GID_ROTATE = GESTURECONFIG_ID{
    .BEGIN = 1,
    .PAN = 1,
};
pub const GID_TWOFINGERTAP = GESTURECONFIG_ID{
    .END = 1,
    .PAN = 1,
};
pub const GID_PRESSANDTAP = GESTURECONFIG_ID{
    .BEGIN = 1,
    .END = 1,
    .PAN = 1,
};
pub const GID_ROLLOVER = GESTURECONFIG_ID{
    .BEGIN = 1,
    .END = 1,
    .PAN = 1,
};

pub const TOUCHEVENTF_FLAGS = packed struct(u32) {
    MOVE: u1 = 0,
    DOWN: u1 = 0,
    UP: u1 = 0,
    INRANGE: u1 = 0,
    PRIMARY: u1 = 0,
    NOCOALESCE: u1 = 0,
    PEN: u1 = 0,
    PALM: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const TOUCHEVENTF_MOVE = TOUCHEVENTF_FLAGS{ .MOVE = 1 };
pub const TOUCHEVENTF_DOWN = TOUCHEVENTF_FLAGS{ .DOWN = 1 };
pub const TOUCHEVENTF_UP = TOUCHEVENTF_FLAGS{ .UP = 1 };
pub const TOUCHEVENTF_INRANGE = TOUCHEVENTF_FLAGS{ .INRANGE = 1 };
pub const TOUCHEVENTF_PRIMARY = TOUCHEVENTF_FLAGS{ .PRIMARY = 1 };
pub const TOUCHEVENTF_NOCOALESCE = TOUCHEVENTF_FLAGS{ .NOCOALESCE = 1 };
pub const TOUCHEVENTF_PEN = TOUCHEVENTF_FLAGS{ .PEN = 1 };
pub const TOUCHEVENTF_PALM = TOUCHEVENTF_FLAGS{ .PALM = 1 };

pub const TOUCHINPUTMASKF_MASK = packed struct(u32) {
    TIMEFROMSYSTEM: u1 = 0,
    EXTRAINFO: u1 = 0,
    CONTACTAREA: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const TOUCHINPUTMASKF_TIMEFROMSYSTEM = TOUCHINPUTMASKF_MASK{ .TIMEFROMSYSTEM = 1 };
pub const TOUCHINPUTMASKF_EXTRAINFO = TOUCHINPUTMASKF_MASK{ .EXTRAINFO = 1 };
pub const TOUCHINPUTMASKF_CONTACTAREA = TOUCHINPUTMASKF_MASK{ .CONTACTAREA = 1 };

pub const REGISTER_TOUCH_WINDOW_FLAGS = enum(u32) { FINETOUCH = 1, WANTPALM = 2, _ };
pub const TWF_FINETOUCH = REGISTER_TOUCH_WINDOW_FLAGS.FINETOUCH;
pub const TWF_WANTPALM = REGISTER_TOUCH_WINDOW_FLAGS.WANTPALM;

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HGESTUREINFO = *opaque {};

// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HTOUCHINPUT = *opaque {};

const CLSID_InertiaProcessor_Value = Guid.initString("abb27087-4ce0-4e58-a0cb-e24df96814be");
pub const CLSID_InertiaProcessor = &CLSID_InertiaProcessor_Value;

const CLSID_ManipulationProcessor_Value = Guid.initString("597d4fb0-47fd-4aff-89b9-c6cfae8cf08e");
pub const CLSID_ManipulationProcessor = &CLSID_ManipulationProcessor_Value;

pub const MANIPULATION_PROCESSOR_MANIPULATIONS = enum(i32) {
    NONE = 0,
    TRANSLATE_X = 1,
    TRANSLATE_Y = 2,
    SCALE = 4,
    ROTATE = 8,
    ALL = 15,
};
pub const MANIPULATION_NONE = MANIPULATION_PROCESSOR_MANIPULATIONS.NONE;
pub const MANIPULATION_TRANSLATE_X = MANIPULATION_PROCESSOR_MANIPULATIONS.TRANSLATE_X;
pub const MANIPULATION_TRANSLATE_Y = MANIPULATION_PROCESSOR_MANIPULATIONS.TRANSLATE_Y;
pub const MANIPULATION_SCALE = MANIPULATION_PROCESSOR_MANIPULATIONS.SCALE;
pub const MANIPULATION_ROTATE = MANIPULATION_PROCESSOR_MANIPULATIONS.ROTATE;
pub const MANIPULATION_ALL = MANIPULATION_PROCESSOR_MANIPULATIONS.ALL;

// TODO: this type is limited to platform 'windows6.1'
const IID__IManipulationEvents_Value = Guid.initString("4f62c8da-9c53-4b22-93df-927a862bbb03");
pub const IID__IManipulationEvents = &IID__IManipulationEvents_Value;
pub const _IManipulationEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ManipulationStarted: *const fn (
            self: *const _IManipulationEvents,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ManipulationDelta: *const fn (
            self: *const _IManipulationEvents,
            x: f32,
            y: f32,
            translationDeltaX: f32,
            translationDeltaY: f32,
            scaleDelta: f32,
            expansionDelta: f32,
            rotationDelta: f32,
            cumulativeTranslationX: f32,
            cumulativeTranslationY: f32,
            cumulativeScale: f32,
            cumulativeExpansion: f32,
            cumulativeRotation: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ManipulationCompleted: *const fn (
            self: *const _IManipulationEvents,
            x: f32,
            y: f32,
            cumulativeTranslationX: f32,
            cumulativeTranslationY: f32,
            cumulativeScale: f32,
            cumulativeExpansion: f32,
            cumulativeRotation: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn _IManipulationEvents_ManipulationStarted(self: *const T, x: f32, y: f32) HRESULT {
                return @as(*const _IManipulationEvents.VTable, @ptrCast(self.vtable)).ManipulationStarted(@as(*const _IManipulationEvents, @ptrCast(self)), x, y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn _IManipulationEvents_ManipulationDelta(self: *const T, x: f32, y: f32, translationDeltaX: f32, translationDeltaY: f32, scaleDelta: f32, expansionDelta: f32, rotationDelta: f32, cumulativeTranslationX: f32, cumulativeTranslationY: f32, cumulativeScale: f32, cumulativeExpansion: f32, cumulativeRotation: f32) HRESULT {
                return @as(*const _IManipulationEvents.VTable, @ptrCast(self.vtable)).ManipulationDelta(@as(*const _IManipulationEvents, @ptrCast(self)), x, y, translationDeltaX, translationDeltaY, scaleDelta, expansionDelta, rotationDelta, cumulativeTranslationX, cumulativeTranslationY, cumulativeScale, cumulativeExpansion, cumulativeRotation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn _IManipulationEvents_ManipulationCompleted(self: *const T, x: f32, y: f32, cumulativeTranslationX: f32, cumulativeTranslationY: f32, cumulativeScale: f32, cumulativeExpansion: f32, cumulativeRotation: f32) HRESULT {
                return @as(*const _IManipulationEvents.VTable, @ptrCast(self.vtable)).ManipulationCompleted(@as(*const _IManipulationEvents, @ptrCast(self)), x, y, cumulativeTranslationX, cumulativeTranslationY, cumulativeScale, cumulativeExpansion, cumulativeRotation);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IInertiaProcessor_Value = Guid.initString("18b00c6d-c5ee-41b1-90a9-9d4a929095ad");
pub const IID_IInertiaProcessor = &IID_IInertiaProcessor_Value;
pub const IInertiaProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialOriginX: *const fn (
            self: *const IInertiaProcessor,
            x: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialOriginX: *const fn (
            self: *const IInertiaProcessor,
            x: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialOriginY: *const fn (
            self: *const IInertiaProcessor,
            y: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialOriginY: *const fn (
            self: *const IInertiaProcessor,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialVelocityX: *const fn (
            self: *const IInertiaProcessor,
            x: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialVelocityX: *const fn (
            self: *const IInertiaProcessor,
            x: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialVelocityY: *const fn (
            self: *const IInertiaProcessor,
            y: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialVelocityY: *const fn (
            self: *const IInertiaProcessor,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialAngularVelocity: *const fn (
            self: *const IInertiaProcessor,
            velocity: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialAngularVelocity: *const fn (
            self: *const IInertiaProcessor,
            velocity: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialExpansionVelocity: *const fn (
            self: *const IInertiaProcessor,
            velocity: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialExpansionVelocity: *const fn (
            self: *const IInertiaProcessor,
            velocity: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialRadius: *const fn (
            self: *const IInertiaProcessor,
            radius: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialRadius: *const fn (
            self: *const IInertiaProcessor,
            radius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundaryLeft: *const fn (
            self: *const IInertiaProcessor,
            left: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BoundaryLeft: *const fn (
            self: *const IInertiaProcessor,
            left: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundaryTop: *const fn (
            self: *const IInertiaProcessor,
            top: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BoundaryTop: *const fn (
            self: *const IInertiaProcessor,
            top: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundaryRight: *const fn (
            self: *const IInertiaProcessor,
            right: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BoundaryRight: *const fn (
            self: *const IInertiaProcessor,
            right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundaryBottom: *const fn (
            self: *const IInertiaProcessor,
            bottom: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BoundaryBottom: *const fn (
            self: *const IInertiaProcessor,
            bottom: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElasticMarginLeft: *const fn (
            self: *const IInertiaProcessor,
            left: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ElasticMarginLeft: *const fn (
            self: *const IInertiaProcessor,
            left: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElasticMarginTop: *const fn (
            self: *const IInertiaProcessor,
            top: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ElasticMarginTop: *const fn (
            self: *const IInertiaProcessor,
            top: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElasticMarginRight: *const fn (
            self: *const IInertiaProcessor,
            right: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ElasticMarginRight: *const fn (
            self: *const IInertiaProcessor,
            right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElasticMarginBottom: *const fn (
            self: *const IInertiaProcessor,
            bottom: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ElasticMarginBottom: *const fn (
            self: *const IInertiaProcessor,
            bottom: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredDisplacement: *const fn (
            self: *const IInertiaProcessor,
            displacement: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredDisplacement: *const fn (
            self: *const IInertiaProcessor,
            displacement: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredRotation: *const fn (
            self: *const IInertiaProcessor,
            rotation: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredRotation: *const fn (
            self: *const IInertiaProcessor,
            rotation: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredExpansion: *const fn (
            self: *const IInertiaProcessor,
            expansion: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredExpansion: *const fn (
            self: *const IInertiaProcessor,
            expansion: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredDeceleration: *const fn (
            self: *const IInertiaProcessor,
            deceleration: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredDeceleration: *const fn (
            self: *const IInertiaProcessor,
            deceleration: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredAngularDeceleration: *const fn (
            self: *const IInertiaProcessor,
            deceleration: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredAngularDeceleration: *const fn (
            self: *const IInertiaProcessor,
            deceleration: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredExpansionDeceleration: *const fn (
            self: *const IInertiaProcessor,
            deceleration: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredExpansionDeceleration: *const fn (
            self: *const IInertiaProcessor,
            deceleration: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialTimestamp: *const fn (
            self: *const IInertiaProcessor,
            timestamp: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialTimestamp: *const fn (
            self: *const IInertiaProcessor,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn (
            self: *const IInertiaProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Process: *const fn (
            self: *const IInertiaProcessor,
            completed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessTime: *const fn (
            self: *const IInertiaProcessor,
            timestamp: u32,
            completed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Complete: *const fn (
            self: *const IInertiaProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompleteTime: *const fn (
            self: *const IInertiaProcessor,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_InitialOriginX(self: *const T, x: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialOriginX(@as(*const IInertiaProcessor, @ptrCast(self)), x);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_InitialOriginX(self: *const T, x: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialOriginX(@as(*const IInertiaProcessor, @ptrCast(self)), x);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_InitialOriginY(self: *const T, y: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialOriginY(@as(*const IInertiaProcessor, @ptrCast(self)), y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_InitialOriginY(self: *const T, y: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialOriginY(@as(*const IInertiaProcessor, @ptrCast(self)), y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_InitialVelocityX(self: *const T, x: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialVelocityX(@as(*const IInertiaProcessor, @ptrCast(self)), x);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_InitialVelocityX(self: *const T, x: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialVelocityX(@as(*const IInertiaProcessor, @ptrCast(self)), x);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_InitialVelocityY(self: *const T, y: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialVelocityY(@as(*const IInertiaProcessor, @ptrCast(self)), y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_InitialVelocityY(self: *const T, y: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialVelocityY(@as(*const IInertiaProcessor, @ptrCast(self)), y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_InitialAngularVelocity(self: *const T, velocity: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialAngularVelocity(@as(*const IInertiaProcessor, @ptrCast(self)), velocity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_InitialAngularVelocity(self: *const T, velocity: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialAngularVelocity(@as(*const IInertiaProcessor, @ptrCast(self)), velocity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_InitialExpansionVelocity(self: *const T, velocity: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialExpansionVelocity(@as(*const IInertiaProcessor, @ptrCast(self)), velocity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_InitialExpansionVelocity(self: *const T, velocity: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialExpansionVelocity(@as(*const IInertiaProcessor, @ptrCast(self)), velocity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_InitialRadius(self: *const T, radius: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialRadius(@as(*const IInertiaProcessor, @ptrCast(self)), radius);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_InitialRadius(self: *const T, radius: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialRadius(@as(*const IInertiaProcessor, @ptrCast(self)), radius);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_BoundaryLeft(self: *const T, left: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_BoundaryLeft(@as(*const IInertiaProcessor, @ptrCast(self)), left);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_BoundaryLeft(self: *const T, left: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_BoundaryLeft(@as(*const IInertiaProcessor, @ptrCast(self)), left);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_BoundaryTop(self: *const T, top: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_BoundaryTop(@as(*const IInertiaProcessor, @ptrCast(self)), top);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_BoundaryTop(self: *const T, top: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_BoundaryTop(@as(*const IInertiaProcessor, @ptrCast(self)), top);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_BoundaryRight(self: *const T, right: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_BoundaryRight(@as(*const IInertiaProcessor, @ptrCast(self)), right);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_BoundaryRight(self: *const T, right: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_BoundaryRight(@as(*const IInertiaProcessor, @ptrCast(self)), right);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_BoundaryBottom(self: *const T, bottom: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_BoundaryBottom(@as(*const IInertiaProcessor, @ptrCast(self)), bottom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_BoundaryBottom(self: *const T, bottom: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_BoundaryBottom(@as(*const IInertiaProcessor, @ptrCast(self)), bottom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_ElasticMarginLeft(self: *const T, left: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_ElasticMarginLeft(@as(*const IInertiaProcessor, @ptrCast(self)), left);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_ElasticMarginLeft(self: *const T, left: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_ElasticMarginLeft(@as(*const IInertiaProcessor, @ptrCast(self)), left);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_ElasticMarginTop(self: *const T, top: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_ElasticMarginTop(@as(*const IInertiaProcessor, @ptrCast(self)), top);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_ElasticMarginTop(self: *const T, top: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_ElasticMarginTop(@as(*const IInertiaProcessor, @ptrCast(self)), top);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_ElasticMarginRight(self: *const T, right: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_ElasticMarginRight(@as(*const IInertiaProcessor, @ptrCast(self)), right);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_ElasticMarginRight(self: *const T, right: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_ElasticMarginRight(@as(*const IInertiaProcessor, @ptrCast(self)), right);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_ElasticMarginBottom(self: *const T, bottom: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_ElasticMarginBottom(@as(*const IInertiaProcessor, @ptrCast(self)), bottom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_ElasticMarginBottom(self: *const T, bottom: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_ElasticMarginBottom(@as(*const IInertiaProcessor, @ptrCast(self)), bottom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_DesiredDisplacement(self: *const T, displacement: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_DesiredDisplacement(@as(*const IInertiaProcessor, @ptrCast(self)), displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_DesiredDisplacement(self: *const T, displacement: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_DesiredDisplacement(@as(*const IInertiaProcessor, @ptrCast(self)), displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_DesiredRotation(self: *const T, rotation: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_DesiredRotation(@as(*const IInertiaProcessor, @ptrCast(self)), rotation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_DesiredRotation(self: *const T, rotation: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_DesiredRotation(@as(*const IInertiaProcessor, @ptrCast(self)), rotation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_DesiredExpansion(self: *const T, expansion: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_DesiredExpansion(@as(*const IInertiaProcessor, @ptrCast(self)), expansion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_DesiredExpansion(self: *const T, expansion: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_DesiredExpansion(@as(*const IInertiaProcessor, @ptrCast(self)), expansion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_DesiredDeceleration(self: *const T, deceleration: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_DesiredDeceleration(@as(*const IInertiaProcessor, @ptrCast(self)), deceleration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_DesiredDeceleration(self: *const T, deceleration: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_DesiredDeceleration(@as(*const IInertiaProcessor, @ptrCast(self)), deceleration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_DesiredAngularDeceleration(self: *const T, deceleration: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_DesiredAngularDeceleration(@as(*const IInertiaProcessor, @ptrCast(self)), deceleration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_DesiredAngularDeceleration(self: *const T, deceleration: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_DesiredAngularDeceleration(@as(*const IInertiaProcessor, @ptrCast(self)), deceleration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_DesiredExpansionDeceleration(self: *const T, deceleration: ?*f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_DesiredExpansionDeceleration(@as(*const IInertiaProcessor, @ptrCast(self)), deceleration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_DesiredExpansionDeceleration(self: *const T, deceleration: f32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_DesiredExpansionDeceleration(@as(*const IInertiaProcessor, @ptrCast(self)), deceleration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_get_InitialTimestamp(self: *const T, timestamp: ?*u32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).get_InitialTimestamp(@as(*const IInertiaProcessor, @ptrCast(self)), timestamp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_put_InitialTimestamp(self: *const T, timestamp: u32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).put_InitialTimestamp(@as(*const IInertiaProcessor, @ptrCast(self)), timestamp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_Reset(self: *const T) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).Reset(@as(*const IInertiaProcessor, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_Process(self: *const T, completed: ?*BOOL) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).Process(@as(*const IInertiaProcessor, @ptrCast(self)), completed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_ProcessTime(self: *const T, timestamp: u32, completed: ?*BOOL) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).ProcessTime(@as(*const IInertiaProcessor, @ptrCast(self)), timestamp, completed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_Complete(self: *const T) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).Complete(@as(*const IInertiaProcessor, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInertiaProcessor_CompleteTime(self: *const T, timestamp: u32) HRESULT {
                return @as(*const IInertiaProcessor.VTable, @ptrCast(self.vtable)).CompleteTime(@as(*const IInertiaProcessor, @ptrCast(self)), timestamp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IManipulationProcessor_Value = Guid.initString("a22ac519-8300-48a0-bef4-f1be8737dba4");
pub const IID_IManipulationProcessor = &IID_IManipulationProcessor_Value;
pub const IManipulationProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedManipulations: *const fn (
            self: *const IManipulationProcessor,
            manipulations: ?*MANIPULATION_PROCESSOR_MANIPULATIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SupportedManipulations: *const fn (
            self: *const IManipulationProcessor,
            manipulations: MANIPULATION_PROCESSOR_MANIPULATIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PivotPointX: *const fn (
            self: *const IManipulationProcessor,
            pivotPointX: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PivotPointX: *const fn (
            self: *const IManipulationProcessor,
            pivotPointX: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PivotPointY: *const fn (
            self: *const IManipulationProcessor,
            pivotPointY: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PivotPointY: *const fn (
            self: *const IManipulationProcessor,
            pivotPointY: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PivotRadius: *const fn (
            self: *const IManipulationProcessor,
            pivotRadius: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PivotRadius: *const fn (
            self: *const IManipulationProcessor,
            pivotRadius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompleteManipulation: *const fn (
            self: *const IManipulationProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessDown: *const fn (
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessMove: *const fn (
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessUp: *const fn (
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessDownWithTime: *const fn (
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessMoveWithTime: *const fn (
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessUpWithTime: *const fn (
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVelocityX: *const fn (
            self: *const IManipulationProcessor,
            velocityX: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVelocityY: *const fn (
            self: *const IManipulationProcessor,
            velocityY: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpansionVelocity: *const fn (
            self: *const IManipulationProcessor,
            expansionVelocity: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAngularVelocity: *const fn (
            self: *const IManipulationProcessor,
            angularVelocity: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinimumScaleRotateRadius: *const fn (
            self: *const IManipulationProcessor,
            minRadius: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinimumScaleRotateRadius: *const fn (
            self: *const IManipulationProcessor,
            minRadius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_get_SupportedManipulations(self: *const T, manipulations: ?*MANIPULATION_PROCESSOR_MANIPULATIONS) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).get_SupportedManipulations(@as(*const IManipulationProcessor, @ptrCast(self)), manipulations);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_put_SupportedManipulations(self: *const T, manipulations: MANIPULATION_PROCESSOR_MANIPULATIONS) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).put_SupportedManipulations(@as(*const IManipulationProcessor, @ptrCast(self)), manipulations);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_get_PivotPointX(self: *const T, pivotPointX: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).get_PivotPointX(@as(*const IManipulationProcessor, @ptrCast(self)), pivotPointX);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_put_PivotPointX(self: *const T, pivotPointX: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).put_PivotPointX(@as(*const IManipulationProcessor, @ptrCast(self)), pivotPointX);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_get_PivotPointY(self: *const T, pivotPointY: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).get_PivotPointY(@as(*const IManipulationProcessor, @ptrCast(self)), pivotPointY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_put_PivotPointY(self: *const T, pivotPointY: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).put_PivotPointY(@as(*const IManipulationProcessor, @ptrCast(self)), pivotPointY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_get_PivotRadius(self: *const T, pivotRadius: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).get_PivotRadius(@as(*const IManipulationProcessor, @ptrCast(self)), pivotRadius);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_put_PivotRadius(self: *const T, pivotRadius: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).put_PivotRadius(@as(*const IManipulationProcessor, @ptrCast(self)), pivotRadius);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_CompleteManipulation(self: *const T) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).CompleteManipulation(@as(*const IManipulationProcessor, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_ProcessDown(self: *const T, manipulatorId: u32, x: f32, y: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).ProcessDown(@as(*const IManipulationProcessor, @ptrCast(self)), manipulatorId, x, y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_ProcessMove(self: *const T, manipulatorId: u32, x: f32, y: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).ProcessMove(@as(*const IManipulationProcessor, @ptrCast(self)), manipulatorId, x, y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_ProcessUp(self: *const T, manipulatorId: u32, x: f32, y: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).ProcessUp(@as(*const IManipulationProcessor, @ptrCast(self)), manipulatorId, x, y);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_ProcessDownWithTime(self: *const T, manipulatorId: u32, x: f32, y: f32, timestamp: u32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).ProcessDownWithTime(@as(*const IManipulationProcessor, @ptrCast(self)), manipulatorId, x, y, timestamp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_ProcessMoveWithTime(self: *const T, manipulatorId: u32, x: f32, y: f32, timestamp: u32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).ProcessMoveWithTime(@as(*const IManipulationProcessor, @ptrCast(self)), manipulatorId, x, y, timestamp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_ProcessUpWithTime(self: *const T, manipulatorId: u32, x: f32, y: f32, timestamp: u32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).ProcessUpWithTime(@as(*const IManipulationProcessor, @ptrCast(self)), manipulatorId, x, y, timestamp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_GetVelocityX(self: *const T, velocityX: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).GetVelocityX(@as(*const IManipulationProcessor, @ptrCast(self)), velocityX);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_GetVelocityY(self: *const T, velocityY: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).GetVelocityY(@as(*const IManipulationProcessor, @ptrCast(self)), velocityY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_GetExpansionVelocity(self: *const T, expansionVelocity: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).GetExpansionVelocity(@as(*const IManipulationProcessor, @ptrCast(self)), expansionVelocity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_GetAngularVelocity(self: *const T, angularVelocity: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).GetAngularVelocity(@as(*const IManipulationProcessor, @ptrCast(self)), angularVelocity);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_get_MinimumScaleRotateRadius(self: *const T, minRadius: ?*f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).get_MinimumScaleRotateRadius(@as(*const IManipulationProcessor, @ptrCast(self)), minRadius);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IManipulationProcessor_put_MinimumScaleRotateRadius(self: *const T, minRadius: f32) HRESULT {
                return @as(*const IManipulationProcessor.VTable, @ptrCast(self.vtable)).put_MinimumScaleRotateRadius(@as(*const IManipulationProcessor, @ptrCast(self)), minRadius);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TOUCHINPUT = extern struct {
    x: i32,
    y: i32,
    hSource: ?HANDLE,
    dwID: u32,
    dwFlags: TOUCHEVENTF_FLAGS,
    dwMask: TOUCHINPUTMASKF_MASK,
    dwTime: u32,
    dwExtraInfo: usize,
    cxContact: u32,
    cyContact: u32,
};

pub const GESTUREINFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    dwID: u32,
    hwndTarget: ?HWND,
    ptsLocation: POINTS,
    dwInstanceID: u32,
    dwSequenceID: u32,
    ullArguments: u64,
    cbExtraArgs: u32,
};

pub const GESTURENOTIFYSTRUCT = extern struct {
    cbSize: u32,
    dwFlags: u32,
    hwndTarget: ?HWND,
    ptsLocation: POINTS,
    dwInstanceID: u32,
};

pub const GESTURECONFIG = extern struct {
    dwID: GESTURECONFIG_ID,
    dwWant: u32,
    dwBlock: u32,
};

//--------------------------------------------------------------------------------
// Section: Functions (10)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn GetTouchInputInfo(
    hTouchInput: ?HTOUCHINPUT,
    cInputs: u32,
    pInputs: [*]TOUCHINPUT,
    cbSize: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn CloseTouchInputHandle(
    hTouchInput: ?HTOUCHINPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn RegisterTouchWindow(
    hwnd: ?HWND,
    ulFlags: REGISTER_TOUCH_WINDOW_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn UnregisterTouchWindow(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn IsTouchWindow(
    hwnd: ?HWND,
    pulFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn GetGestureInfo(
    hGestureInfo: ?HGESTUREINFO,
    pGestureInfo: ?*GESTUREINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn GetGestureExtraArgs(
    hGestureInfo: ?HGESTUREINFO,
    cbExtraArgs: u32,
    // TODO: what to do with BytesParamIndex 1?
    pExtraArgs: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn CloseGestureInfoHandle(
    hGestureInfo: ?HGESTUREINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn SetGestureConfig(
    hwnd: ?HWND,
    dwReserved: u32,
    cIDs: u32,
    pGestureConfig: [*]GESTURECONFIG,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "user32" fn GetGestureConfig(
    hwnd: ?HWND,
    dwReserved: u32,
    dwFlags: u32,
    pcIDs: ?*u32,
    pGestureConfig: [*]GESTURECONFIG,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HWND = @import("../../foundation.zig").HWND;
const IUnknown = @import("../../system/com.zig").IUnknown;
const POINTS = @import("../../foundation.zig").POINTS;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
